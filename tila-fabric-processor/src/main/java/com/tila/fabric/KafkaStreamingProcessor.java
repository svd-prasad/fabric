/*
 * Copyright 2016 ANI Technologies Pvt. Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.tila.fabric;

import com.fasterxml.jackson.databind.ObjectMapper;
//import com.olacabs.fabric.common.Document;
import com.olacabs.fabric.compute.ProcessingContext;
import com.olacabs.fabric.compute.processor.InitializationException;
import com.olacabs.fabric.compute.processor.ProcessingException;
import com.olacabs.fabric.compute.processor.StreamingProcessor;
import com.olacabs.fabric.compute.util.ComponentPropertyReader;
import com.olacabs.fabric.model.common.ComponentMetadata;
import com.olacabs.fabric.model.event.Event;
import com.olacabs.fabric.model.event.EventSet;
import com.olacabs.fabric.model.processor.Processor;
import com.olacabs.fabric.model.processor.ProcessorType;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.Properties;

/**
 * Created by User: prasadkotikalapudi
 * Date: 2019-07-10
 * Time: 13:25
 */
@EqualsAndHashCode(callSuper = false)
@Slf4j
@Data
@Processor(namespace = "global",
        name = "tila-fabric-processor",
        version = "0.0.1",
        description = "Sample processor generated by maven archetype",
        cpu = 0.5, memory = 512,
        processorType = ProcessorType.EVENT_DRIVEN,
        requiredProperties = {},
        optionalProperties = {}
)
public class KafkaStreamingProcessor extends StreamingProcessor {

    private ObjectMapper mapper;

    /**
     * Variables to hold the properties defined in the annotation
     */
    private String sampleUrl;
    private boolean sampleBool;
    private int sampleInt;
    private String sampleOptionalProp;

    @Override
    public void initialize(final String instanceId, final Properties globalProperties, final Properties properties,
                           final ComponentMetadata componentMetadata) throws InitializationException {

        /** Example of capturing different properties in code defined in the annotations */
        this.sampleUrl = ComponentPropertyReader.readString(properties, globalProperties, "sampleString", instanceId, componentMetadata);
        this.sampleBool = ComponentPropertyReader.readBoolean(properties, globalProperties, "sampleBool", instanceId, componentMetadata);
        this.sampleInt = ComponentPropertyReader.readInteger(properties, globalProperties, "sampleInt", instanceId, componentMetadata);

        this.sampleOptionalProp = ComponentPropertyReader.readString(properties, globalProperties, "sampleOptionalProp", instanceId, componentMetadata, "default_value");

        /** You should do initialization of all the libs or clients
         this method is called once while start of a topology.
         hence all init calls must happen in this section
         **/
        this.mapper = new ObjectMapper();
    }

    /**
     * Consume block is called in a loop from the framework
     * The logic in this section, must be the core logic for the processor
     **/
    @Override
    protected EventSet consume(final ProcessingContext processingContext, final EventSet eventSet) throws ProcessingException {

        /** Below is an example to get document from event
         Put your core logic in similar fashion */
        for (final Event event : eventSet.getEvents()) {
            try {
                final Object doc = mapper.readValue((byte[]) event.getData(), Object.class);
                log.info("Document Id - {}", doc);

                /**
                 * if global property of the topology "eventset.is_serialized" is set to true
                 * then framework deserialize the document and sets the jsonNode
                 */
                log.info("JsonNode - {} ", event.getJsonNode());

            } catch (final IOException e) {
                log.error("Error - {}", e.getMessage(), e);
                throw new ProcessingException(e);
            }
        }

        return eventSet;
    }

    @Override
    public void destroy() {
        /** destroy or stop your objects or clients here... */
    }
}
